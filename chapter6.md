# 並行性

- "並行処理":複数のコードが、あたかも同時に実行されているように振る舞うこと(マルチプロセス・マルチスレッド)
- "並列処理":複数のコードが本当に同時に実行されること行されること(複数の CPU ・複数のコンピューターを用いたシステム)

## 33 時間的な結合を破壊する

ソフトウェアアーキテクチャーにおける時間の観点

- 並行性(同時に発生すること)
- 順序(時間軸上における相対的な位置関係)

ワークフロー分析やアーキテクチャー、設計、配置計画等、さまざまな開発分野における柔軟性を向上させ、時間に関連した依存関係を削減できるようになり、より迅速に、かつより信頼性に優れた、予測しやすいシステムが得られるはずです。

### 並行部分を探す

多くのプロジェクトで、アプリケーションのワークフローのモデル化・分析、それと同時に、発生する操作・操作の順序を洗い出す必要があります。
この作業を行う方法のひとつに「アクティビティー図」といった表記法を用いてワークフローを補足するという手があります。

**Tip 56**：並行性を向上させるためにワークフローを分析する

### 並行処理の機会

アクティビティ図では並行処理が可能な箇所の洗い出しはできる。
ただ、並行処理実施の可否は設計者が判断する必要がある(コード以外のところで時間のかかる手順を見つける)。

### 並列処理の機会

並列処置が適している物事は分割した個々の作業が比較的独立しており、他の作業を待つという状況がないものです。
よくあるやり方は、大きな作業の塊を独立した小さな塊に分割し、それぞれを並列に処理した後、結果を組み合わせるというも結果を組み合わせるというものです。

### 機械の洗い出しは難しくない

並行処理や並列処理が効果を発揮する場所を見つけ出した後は、それらを如何に安全に実装するかです。
それについては、この章の後半で解説しています。

### チャレンジ

## 34 共有状態は間違った状態

**Tip 57**:共有状態は間違った状態

お互いの状態を気にせず処理を行うため、問題が発生するケースがある。(口座の処理・レストランの陳列棚)

### 非アトミックな更新

複数のプロセスが同じメモリー領域に書き込めるため、参照したメモリーの整合性を保証できない点に問題がある。
対策として、アトミックな操作にする方法がある。

#### セマフォー、そしてその他の相互排他形式

セマフォーは、ある時点で誰か 1 人しか占有できない「何らかのもの」。
セマフォーを作成しておけば、何らかのリソースへのアクセスを統制するために使用することができる。

このアプローチにはいくつか問題がある。
最も大きな問題はおそらく、この規約が周知徹底されていなければならないというところにある。
誰かがルールを無視した場合（つまり、開発者の 1 人が規約に従わないコードを記述した場合）、状況は混沌としたものに逆戻りします。

#### リソースをトランザクション化する

現時点での設計は、データへのアクセスという責務を、使用する人に委譲しているという点で貧弱なものとなっています。
そこで、データのアクセスを関数化し、単一の呼び出しで実行できるように変更する。
変更時に、関数内でセマフォによるアクセス制限や例外発生時の対応(セマフォがアンロックされない)についても対応させる。

### 複数リソースのトランザクション

上記のトランザクションを複数のリソースに対して適用した場合、片方のリソースを自分が持ち、もう片方のリソースを別の人が持つことで処理が終了しない可能性がある。
そこで、簡単な対応としては例外として何かが失敗した場合にリソースを開放することが考えられるが、これだと肝心の業務ロジックが、さまざまな雑事の中に埋もれてしまう。
良いと思われる方法として、それぞれの構成要素への参照を保持した、ある種のメニュー項目を用意しておき、 包括的なメソッドを通じてリソースをやり取りさせるのがよい。

### トランザクション以外での更新

**Tip 58**:無秩序なエラーはしばしば並行処理によって引き起こされる

### その他の排他的アクセス

ほとんどの言語には、外部ライブラリーとして共有リソースに対するある種の排他的アクセス機構がサポートされており、言語によってはデフォルトでサポートされているものもある(Rust)。

### お医者さん！ 痛むのです……｡

このセクションで得るものがなかったという方は、次の教訓を忘れないようにしてください。
それは、共有リソース環境における並行処理は難しく、その管理は苦難の連続だというものです。

## 35 アクターとプロセス

アクターとプロセスによって、共有メモリーの同期という重荷を背負うことなく並行処理を実現する興味深い方法が提供される。

- 「アクター」は、局所的かつ固有の（プライベートな）状態を保持した、独立した仮想プロセッサーです。そして、各アクターはメールボックスを備えています。メールボックスにメッセージが届いた際、そのアクターが待機中なのであれば、活動を開始しそのメッセージを処理します。処理が完了した場合、メールボックス中の別のメッセージを処理するか、メールボックスが空であれば待機状態に戻ります。メッセージを処理する際、アクターは他のアクターを生成したり、存在を知っている他のアクターにメッセージを送ったり、次のメッセージを処理する際に遷移する新たな状態を作り出したりすることができます。
- 「プロセス」は通常の場合、より汎用目的の仮想プロセッサーであり、並行処理を容易にする目的で、しばしば OS によって実装されます。プロセスは、（規約によって）アクターのように振る舞うような制約が課されており、ここではそれがプロセスの型となります。

### アクターは並行状態のみが存在する

アクターの定義に「記述されていない」ものごとがいくつかある。

- 統制されている「ものごと」は 1 つも存在していません。次に起こることを決めたり、生データから最終的な出力に情報を移送する上での調整役となるようなものは存在していません。
- システムにおける「唯一の状態」はメッセージと各アクターがローカルに保持する状態に格納されています。メッセージは受け取り側が読み出す以外の手段で内容を確認できず、ローカルの状態はアクターの外からアクセスすることはできません。
- すべてのメッセージは一方通行となり、応答という考え方はありません。アクターからの応答を要求する場合、メッセージ送信側は自らのメールボックスを用意し、メッセージ内にそのアドレスを含めておきます。これにより、まったく別のメッセージとして応答が（どこかの時点で）メールボックスに送られてきます。
- アクターによる各メッセージの処理は、 1 つずつ行われます。

**Tip 59**:共有状態を持たないアクターを並行処理で使用する

### シンプルなアクター

Pass(サンプルによる説明のため)

### 明示的でない並行処理

アクターモデルでは、状態を共有しないため、並行処理を扱うコードを一切記述する必要がなく、アクターは自らが受け取ったメッセージベースで動作するため、エンドツーエンドでの「これを実行し、あれを実行する」といったロジックも明示的に記述する必要ない。

この種のコンポーネントは、単一プロセッサー上でも、複数コア上でも、ネットワーク上に配置された複数のマシンでも同様に機能するため、基盤となるアーキテクチャーについての指示もない。

### Erlang におけるアクターモデル

Pass(実例紹介のため)

## 36 ホワイトボード

ホワイトボードによるこういったアプローチの持つ重要な特徴

- 誰もお互いの存在を知る必要がありません。彼らはホワイトボードから新たな情報を引き出し、自分の見つけたものをそこに書き込んでいくだけなのです。
- 誰もが異なった教育レベルや技術レベルであっても構わないし、同じ地域に所属している必要さえないのです。彼らは目標こそ共有しているものの、それがすべてなのです。
- 誰もがプロセスの過程で出入りすることもでき、また異なったシフトで捜査することもできます。
- ホワイトボードに記述する内容に関する制限はありません。絵でも文章でも物証でも何でも構わないのです。

### ホワイトボードの使用例

(使用例は Pass)

ワークフローシステムから、考えられ得るすべての組み合わせと状況を扱うシステムが作成できるが、複雑かつプログラマーの介入が必要となっているはず。
規則が変わるとワークフローは再編成しなければならない。(手続きの変更とともに、定められた動作を記述していたコードは開発し直さなければならない)

解決方法としてホワイトボードに、法的要求をカプセル化したルールエンジンを協調させるというものがある。
データの到来順序がバラバラであっても、事実が投稿されたタイミングで適切なルールが起動される。
同様にフィードバックも簡単に取り扱える。
ルール群からの出力をホワイトボードに書き出すと、他の適用可能なルール群が呼び出されるようにしておく。

**Tip 60**:ワークフローを協調させるためにはホワイトボードというコンセプトを活用すること

### メッセージシステムはホワイトボードのようになる

永続性(イベントログの形式による)とパターンマッチング形式によるメッセージの取得能力は、ホワイトボードシステムとして、and/or プラットフォームとして利用しながらアクターを実行できることを意味する。

### とは言うものの、話はそう簡単ではない……

- メリット
  - アプリケーションから並行処理の問題の芽は摘み取れる
  - システムの粒度を細かくでき、個々のアクターを置き換えることでシステム全体を止めることなくアップデートできる
- デメリット
  - 多くのアクションが影響し合うため、予測しにくいものになる
  - メッセージ形式 and/or API の中央リポジトリーを設置しておくことも重要
  - メッセージや事実がシステムを通じてやり取りされるさまをトレースできる優れたツールも必要
  - 配備や管理がより難しくなる可能性もあります。ただこういった問題は、

### チャレンジ
