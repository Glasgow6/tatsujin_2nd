# 第4章　妄想の達人

## 概要
完璧なソフトウェアを作ることはできない。
その事実に基づいて、
## 23　契約による設計 (DbC)
### 契約による設計とは
ソフトウェアモジュールの権利と責務を文書化し、プログラムの正しさを保証する技法。
* 事前条件が保証されていなければ機能呼び出しを拒否
* 事後条件によって、機能終了後の状態を保証（無限ループは存在できない）
* クラス不変表明により、呼び出し側に対して常に真となることを保証する条件

**事前条件が満足されたとき、処理完了時点で事後条件と不変表明は満足される。**という契約が成立し、満たされない場合は例外処理を行う。

たとえばPythonでは以下のように書ける（[参考記事リンク](https://qiita.com/usop4/items/7d0a039616902d644f82)）
一部は型アノテーションで代用が可能。
```python
from contracts import contract

# pattern 1
@contract(a='int,>0', b='int,>0', returns='int')
def my_add(a, b):
    return a+b

print(my_add(1,1)) # 普通に実行される
print(my_add(1,1.1)) # ちゃんとクラッシュする

# pattern 2
@contract
def my_add2(a : 'int,>0', b : 'int,>0') -> 'int':
    return a+b

print(my_add2(1,1))
print(my_add2(1,1.1))

# pattern 3
@contract
def my_add3(a, b):
    """ Function description.
        :type a: int,>0
        :type b: int,>0
        :rtype: int
    """
    return a+b
print(my_add3(1,1))
print(my_add3(1,1.1))

```

DbCとテストはプログラムの正確性という幅広い対象に向かう共通点があるが、そのアプローチが異なる。TDDはテスト中におけるコードの普遍性チェックには重きを置いていない。

### 早めのクラッシュ
DbCによる事前条件や事後条件でクラッシュを早期に検知することで、異常箇所の特定が素早く行える。NaNが算出されたまま後続の処理を続けていくと、摩訶不思議な結果が生み出され、特定が難しくなる。
また、障害によるダメージを最小限に抑えることもできる。

### セマンティック不変表明
ものごとの意味の中心にある大前提。変更される可能性のある単なるポリシーではない。重要な要求があるのであれば、ドキュメントの核心として書く。それはシステムを使用するすべてのユーザーと我々の行動を保証するための契約となる。

### チャレンジ
DbCはなぜ広く使われないのか。

## 24　死んだプログラムは嘘をつかない
エラーは情報を与えてくれる。エラーがあれば確実に読む。
### キャッチ＆リリース
例外をすべてキャッチして処理を書かない。理由は以下。
* 本来のコードがエラーハンドリングに埋もれる
* コードの結合度を下げる。

# 25　表現を用いたプログラミング
ありえないなんてことはありえない。の気持ちを持つ。起こらないなら表現によって保証する。
 ```assert``` を使うのだ。起こり得ないことをチェックするので、エラーハンドリングのために使ってはならない。


```Python
# これはVery bad
puts("Enter 'Y' or 'N': ")
ans = gets[0]
assert((ch == 'Y') || (ch == 'N'))
```

ああ。